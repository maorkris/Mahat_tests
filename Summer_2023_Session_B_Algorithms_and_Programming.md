                       חלק א׳       
#### ענו על ארבע מבין השאלות 6-1 (ערך כל שאלה – 12 נקודות) 


                    (12 נק') שאלה 1
כתבו קטע קוד שקולט מספרים שלמים עד שייקלט מספר תלת ספרתי.
יש להדפיס את מספר הגדול ביותר שנקלט ואת מספר הקטן שנקלט.


```python
def func1():
    # הגדרת משתנים למספר המקסימלי והמינימלי
    max_val = None
    min_val = None
    
    # אתחול לולאה אינסופית
    while True:
        # קליטת מספר מהמשתמש
        user_input = int(input("אנא הכנס מספר:"))
    
        # בדיקה אם המספר הוא מספר תלת-ספרתי
        if 99 < abs(user_input) <= 999:
            break
    
        # בדיקה אם זו הפעם הראשונה שמספר מתקבל
        if max_val is None and min_val is None:
            max_val = user_input
            min_val = user_input
    
        # בדיקה אם המספר החדש הוא המספר הגדול ביותר שהתקבל עד כה
        if user_input > max_val:
            max_val = user_input
    
        # בדיקה אם המספר החדש הוא המספר הקטן ביותר שהתקבל עד כה
        if user_input < min_val:
            min_val = user_input
    
    # הדפסת המספר הגדול ביותר והקטן ביותר שהתקבלו
    print(f"המספר הגדול ביותר שהתקבל: {max_val}\nהמספר הקטן ביותר שהתקבל: {min_val}")
```



                שאלה 2

(6 נק') א. מחרוזת "תקינה" היא מחרוזת העונה לשני תנאים הבאים:
• אורך המחרוזת אי-זוגי.
• תו ראשון זהה לתו אמצעי וזהה לתו האחרון.
לדוגמה: המחרוזת **"AbbAc1A"** היא "מחרוזת תקינה".

כתבו פעולה המקבלת מחרוזת ובודקת אם היא "מחרוזת תקינה".
אם כן – הפעולה תחזיר ערך True , ולא – הפעולה תחזיר ערך False.

כותרת הפעולה: is_valid(s)

```python


# פונקציה שבודקת אם מחרוזת היא "תקינה"
def is_valid(s):
    # הגדרת משתנים שיכילו את התווים: הראשון, האמצעי והאחרון במחרוזת

    first_char,mid_char, last_char = s[0], s[len(s) // 2], s[len(s) -1]
    # בדיקה אם אורך המחרוזת הוא אי-זוגי ובנוסף שהתו הראשון, האמצעי והאחרון זהים
    if len(s) % 2 != 0 and first_char == mid_char == last_char:
        return True

    return False 

```

         (6 נק') ב׳         
כתבו קטע קוד הקולט 23 מחרוזות.
הקטע יחשב וידפיס מספר "מחרוזות תקינות" ומספר מחרוזות לא תקינות.
יש להשתמש בפעולה שכתבתם בסעיף א׳.

```python
def func2():
    # משתנה שמחזיק את מספר המחרוזות התקניות
    validated_strings_count = 0
    
    # לולאה שרצה 23 פעמים
    for i in range(23):
        # קליטת מחרוזת מהמשתמש
        user_input = input("אנא הכנס מחרוזת:")
    
        # בדיקה אם המחרוזת היא תקנית
        if is_valid(user_input):
            # אם המחרוזת תקנית, מוסיפים 1 למשתנה valid
            validated_strings_count += 1
    
    # הדפסת מספר המחרוזות התקניות והלא תקניות
    print(f"מספר המחרוזות התקניות: {validated_strings_count}\nמספר המחרוזות הלא תקניות: {23 - validated_strings_count}")

```


      (12  נק') שאלה 3               
רשימה של מספרים שלמים נקראת "רשימה מאוזנת" אם היא עונה על תנאים הבאים:
• כמות האיברים החיוביים שווה לכמות האיברים השליליים.
• הרשימה לא כולל אפסים. כתבו פעולה המקבלת רשימה של מספרים שלמים.
אם הרשימה מאוזנת יש להדפיס אותה מתחילתה ועד סופה בשורה אחת,
ולא – יש להדפיס אותה בסדר הפוך (מסוף הרשימה להתחלה).


```python
def is_balanced(arr):
    # משתנה שמחזיק את מספר האיברים החיוביים ברשימה
    positive_counter = 0

    # בדיקה אם מספר האיברים ברשימה הוא מספר זוגי
    if len(arr) % 2 == 1:
        return False

    # עוברים על כל איבר ברשימה
    for i in arr:
        # אם האיבר הוא אפס, הרשימה אינה מאוזנת
        if i == 0:
            return False

        # אם האיבר הוא מספר חיובי, מוסיפים 1 למונה
        elif i > 0:
            positive_counter += 1

    # בדיקה אם מספר האיברים החיוביים שווה למספר האיברים השליליים
    return len(arr) - positive_counter == positive_counter
  ```



      שאלה 4                  
חברת "פרחי הארץ" מגדלת פרחים ושולחת אותם למכירה לחוץ לארץ.
נתונה מחלקה FlowerPackage המייצגת משלוח פרחים המיועד לשליחה לחו"ל.
למחלקה יש את התכונות הבאות:
• type – סוג הפרח, מטיפוס מחרוזת. •
num – מספר פרחים במשלוח, מטיפוס מספר שלם. 
• time – מספר שעות שניתן להחזיק את הפרחים ללא מים, מטיפוס מספר שלם.
• price – מחיר פרח בודד, מטיפוס מספר ממשי.


במחלקה הוגדרה פעולה בונה (בנאי) המקבל פרמטרים לכל התכונות.
(4 נק') א. כתבו פעולה בונה המקבלת סוג פרח ומחיר. הפעולה מייצרת משלוח סטנדרטי של 2,000 פרחים.
זמן סטנדרטי שאפשר להחזיק את הפרחים ללא מים – 12 שעות.


```python

class FlowerPackage:
    # פעולה בונה שמקבלת את סוג הפרח, מספר הפרחים, זמן האחסון ללא מים ומחיר הפרח
    def __init__(self, type, num, time, price):
        self.type = type  # סוג הפרח
        self.num = num  # מספר הפרחים
        self.time = time  # זמן האחסון ללא מים
        self.price = price  # מחיר הפרח

    # פעולה שמייצרת משלוח סטנדרטי של 2000 פרחים עם זמן אחסון של 12 שעות
    def delivery(self,flower_type, flower_price):

        # יצירת משלוח חדש עם הפרמטרים הנתונים והגדרות סטנדרטיות למספר הפרחים וזמן האחסון
        new_delivery = FlowerPackage(flower_type,num =2000, time=12, price=flower_price)
        return new_delivery  # מחזירה את המשלוח החדש

```
            (8 נק') ב


עקב בעיות לוגיסטיות, חברת התעופה מציעה מסלול טיסה ארוך יותר.
חלק ממשלוחים לא ישרדו טיסה ארוכה ואז אי אפשר יהיה למכור את הפרחים.
"פרחי הארץ" תדרוש מחברת התעופה פיצוי על ההפסד הכספי.
כתבו פעולה חיצונית המקבלת רשימה הפניות לעצמים מסוג FlowerPackage בשם arr ואורך הטיסה flyTime.
הפעולה תדפיס פרטי המשלוחים שלא יהיו תקינים.
הפעולה גם תחשב ותדפיס סכום ש"פרחי הארץ" הפסידה. כותרת הפעולה:
                    compensation(arr, flyTime)
                    
הנחה: כל איבר ברישמה מכיל הפניה לעצם מסוג FlowerPackage ואין איברים שערכם שווה ל- null.
                    
```python

def compensation(arr, flyTime):
    """
    מחשב את הפיצוי עבור כל הפרחים שזמן ה- flyTime גדול מזמן חיי הפרחים
    הפיצוי מחושב כך: מספר הפרחים כפול המחיר.
    """
    compensation = 0
    for flower in arr:
        if flyTime > flower.time:
            compensation += flower.num * flower.price

    return compensation
```


####  חלק ב' ענו על שתיים מבין השאלות 9-7 (ערך כל שאלה – 15 נקודות).

לפי התקנון של רשות המים, חיוב עבור צריכת מים ביתית מתבצע לפי השיטה הבאה:
צריכת המים נקבעת על פי קריאת מד המים.
ההפרש בין הקריאה הנוכחית לקריאה הקודמת קובע את כמות הצריכה.
תעריפי המים אחידים בכל הארץ וקובעת אותם הרשות הממשלתית למים וביוב.
סכום החיוב הוא מכפלה של כמויות המים שנצרכו בתקופת החשבון בתעריפי המים.
צריכה ביתית כוללת שני תעריפים:

• תעריף מוזל המתייחס לכמות של שבעה מ"ק לכל נפש המתגוררת ביחידת הדיור.
• ותעריף גבוה המתייחס ליתרת כמות המים שנצרכה ביחידת הדיור בתקופת החשבון. לדוגמה:
אם הצריכה הביתית הייתה 35 מ"ק מים ובדירה מתגוררות ארבע נפשות
יש לשלם עבור 7*4=28 מ"ק לפי התעריף המוזל
ועבור 35-28=7 מ"ק לפי התעריף הגבוה.

חברת "מי הארץ" החליטה למחשב את תהליך גביית התשלום.
לצורך כך הגדירו את המחלקה לקוח (Client) המייצגת יחידת דיור.
למחלקה יש התכונות הבאות:
• address – כתובת, מטיפוס מחרוזת.
• persons – מספר נפשות, מטיפוס מספר שלם.
• current – קריאת מד המים נוכחית, מטיפוס מספר שלם.
• prev – קריאת מד המים קודמת, מטיפוס מספר שלם.

```python
class Client:
    def __init__(self, address, persons, current, prev):
        """
        פעולה בונה של האובייקט Client.

        :param address: כתובת הלקוח.
        :param persons: מספר האנשים בבית.
        :param current: צרילת הצרילות הנוכחית.
        :param prev: צרילת הצרילות הקודמת.
        """
        self.address = address
        self.persons = persons
        self.current = current
        self.prev = prev

    # (5 נק') א'
    #  כתבו במחלקה Client פעולה לעדכון קריאת מד המים נוכחית.
    # הפעולה מקבלת מספר שלם new_current ומעדכנת תכונות current ו- prev בהתאם. כותרת הפעולה:
    # update_current(new_current)

    def update_current(self, new_current: int):
        """
        פעולה שמעדכנת את הצריכה הקודמת ובהתאם את הנוכחית.
        :param new_current: ערך של הצריכה החדשה.
        """

        self.prev = self.current
        self.current = new_current
   ```

               (5 נק') ב׳


 כתבו במחלקה Client את הפעולה לחישוב תשלום.
 הפעולה מקבלת שני תעריפים rate1 (תעריף מוזל) ו-rate2 (תעריף גבוה).
 הפעולה תחזיר סכום לתשלום לפי תקנון של רשות המים. כותרת הפעולה:
 payment(rate1, rate2)
```python
    def payment(self, rate1, rate2):
        """
        פעולה שמחשבת את סכום התשלום על פי תעריפים נתונים.

        :param rate1: תעריף מוזל עבור השימוש במים .
        :param rate2: תעריף רגיל עבור שימוש נוסף מעבר לתקרה המותרת.
        :return: הסכום הכולל לתשלום.
        """

        # משתנה שמייצג את הצריכה במים שיש לשלם
        total_current = self.current - self.prev
        # יצירת משתנה לתיאום התעריף לפי מספר האנשים בבית
        discount_rate = self.persons * 7

        # בדיקה האם הצריכה גדולה או שווה לכמות המים הנתונים פר 7 קוב לנפש
        if  total_current <= discount_rate :
            #הפונקציה תחזיר את התשלום לפי התעריך המוזל
            return total_current * rate1
        else:
            # חישוב תשלום עבור השימוש הנוסף מעבר לתקרה המוזלת
            carry = (total_current - discount_rate) * rate2
            return carry + (discount_rate * rate1)
   ```


                   (5 נק') ג.

 """ הנהלת חברת "מי הארץ" החליטה להציע ללקוחות שלה בדיקת מד המים בחינם.
 בשלב ראשון הוחלט לבדוק את מד המים אצל לקוחות שהתשלום
 שלהם גבוה ביחס למשפחות עם אותו מספר נפשות.

 כתבו פעולה חיצונית המקבלת רשימת לקוחות (הפניות לעצמים מטיפוס Client), מספר שלם
 חיובי num המציין את מספר הנפשות ביחידת הדיור ושני תעריפים rate1 (מוזל) ו- rate2 (גבוה).
 הפעולה תדפיס כתובת של כל הלקוחות שיש להם num נפשות ביחידת דיור והתשלום שלהם
 גבוה מממוצע התשלומים של לקוחות עם אותו מספר נפשות. כותרת הפעולה:
 proposal(arr, num, rate1, rate2)"""
```python
def proposal(arr, num, rate1, rate2):
    """
    הפונקציה מחשבת את התשלום הממוצע של לקוחות שמספר האנשים בבית שלהם שווה ל-num.
    לאחר מכן, הפונקציה מדפיסה את כתובת הלקוח אם התשלום שלו גדול מהתשלום הממוצע.

    :param arr: רשימה של אובייקטים מסוג Client.
    :param num: מספר שלם שמייצג את מספר האנשים בבית.
    :param rate1: תעריף מוזל לשימוש במים.
    :param rate2: תעריף רגיל לשימוש במים שמעבר לתקרה המותרת.
    """

    # מאתחלים את הסכום הכולל של התשלומים ואת מונה הלקוחות ל-0
    total_payment = 0
    count = 0
    # מעבר על כל הלקוחות ברשימה
    for client in arr:
        # אם מספר האנשים בבית של הלקוח שווה ל-num
        if client.persons == num:
            # מוסיפים את תשלום הלקוח לסכום הכולל של התשלומים
            total_payment += client.payment(rate1, rate2)
            # מוסיפים 1 למונה הלקוחות
            count += 1
    # מחשבים את התשלום הממוצע
    average_payment = total_payment / count
    # מעבר שוב על כל הלקוחות ברשימה
    for client in arr:
        # אם מספר האנשים בבית של הלקוח שווה ל-num ותשלום הלקוח גדול מהתשלום הממוצע
        if client.persons == num and client.payment(rate1, rate2) > average_payment:
            # מדפיסים את כתובת הלקוח
            print(client.address)
```

                      שאלה 9

נתונות ההגדרות הבאות:
• "משקל נקי" של מספר שלם חיובי הוא סכום הספרות של המספר
בלי הספרה השמאלית ביותר ובלי הספרה הימנית ביותר.
                לדוגמה:
ה"משקל הנקי" של 123 הוא 2.
ה"משקל הנקי" של 12345- הוא 2+3+4=9.
ה"משקל הנקי" של 18 הוא 0.
ה"משקל הנקי" של 9 הוא 0.
• רשימה של מספרים שלמים נקראת "רשימה ממוינת לפי משקלים"
אם ה"משקלים" של כל איברי הרשימה ממוינים בסדר עולה ממש
(ללא חזרות של משקל). לדוגמה: הרשימה הבאה "ממוינת לפי משקלים"

   `[35, 923, 781,1892, 12349, 1892]       `         

                   (3 נק') א


 כתבו פעולה אשר מקבלת מספר שלם חיובי ומחזירה את ה"משקל הנקי" שלו
```python
 def clean_weight(num):
    """
פונקציה שמחשבת את "משקל הנקי" של מספר שלם חיובי.
"משקל נקי" הוא סכום הספרות של המספר ללא הספרה השמאלית ביותר וללא הספרה הימנית ביותר.
:param num: מספר שלם חיובי.
:return: משקל הנקי של המספר.
"""
    # המרת המספר למחרוזת
    num_str = str(num)
    # משתנה לסכום המשקל
    sum_weight = 0
    # לולאה שעוברת על כל הספרות של המספר ללא הספרה השמאלית ביותר וללא הספרה הימנית ביותר
    for i in range(1, len(num_str) - 1):
        # הוספת הספרה לסכום המשקל
        sum_weight += int(num_str[i])
    # החזרת המשקל הנקי של המספר
    return sum_weight
```

                   (5 נק') ב


  כתבו פעולה אשר מקבלת רשימה של מספרים שלמים ומחזירה ערך `True`
 אם הרשימה היא "רשימה ממוינת לפי משקלים", ולא הפעולה תחזיר ערך `False`.
```python
def sort_weight_arr(arr):
    """
    פונקציה שבודקת אם רשימה של מספרים שלמים ממוינת לפי "משקל נקי".
    :param arr: רשימה של מספרים שלמים.
    :return: True אם הרשימה ממוינת לפי "משקל נקי", אחרת False.
    """
    # לולאה שעוברת על כל האיברים ברשימה
    for i in range(len(arr) - 1):
        # בדיקה אם "משקל הנקי" של האיבר הנוכחי גדול מ"משקל הנקי" של האיבר הבא
        if clean_weight(arr[i]) > clean_weight(arr[i + 1]):
            # אם זה המצב, הרשימה אינה ממוינת לפי "משקל נקי"
            return False
    # אם הגענו לסוף הרשימה ללא שום בעיה, הרשימה ממוינת לפי "משקל נקי"
    return True
```

                   (5 נק') ג

   
  כתבו פעולה אשר מקבלת שתי רשימות של מספרים שלמים וחיוביים.
  כל את מהרשימות היא "רשימה ממוינת לפי משקלים". הפעולה תדפיס את כל האיברים עם "משקל הנקי" ייחודי
  (כלומר את כל האיברים מהרשימה הראשונה ש"המשקל הנקי" שלהם לא מופיע ברשימה השני ואת ככל האיברים מהרשימה השנייה ש"המשקל הנקי" שלהם לא מופיע ברשימה הראשונה).
  לדוגמה: עבור שתי הרשימות

`list1 = [35, 923, 781, 12349, 1892]`

`list2 = [2, 358, 181, 5821, 1742, 36621, 27731]`

  הפלט יהיה:
  `[923, 12349, 358, 5821, 1742, 36621]`
```python
def create_dict(lst):
    """
פונקציה שמקבלת רשימה של מספרים שלמים ויוצרת מילון שבו המפתחות הם "משקלים נקיים"
של המספרים והערכים הם המספרים עצמם.
:param lst: רשימה של מספרים שלמים.
:return: מילון שבו המפתחות הם "משקלים נקיים" של המספרים והערכים הם המספרים עצמם.
"""
    # יצירת מילון ריק
    dct = {}
    # לולאה שעוברת על כל האיברים ברשימה
    for i in lst:
        # בדיקה אם האיבר לא נמצא כבר במילון
        if i not in dct:
            # אם האיבר לא נמצא במילון, מוסיפים אותו למילון עם המפתח שהוא "משקל הנקי" של המספר
            dct[clean_weight(i)] = i
    # החזרת המילון
    return dct

def unick_arr(lst1, lst2):

    """
    פונקציה שמקבלת שתי רשימות של מספרים שלמים ומחזירה רשימה של כל האיברים ש"משקל הנקי" שלהם ייחודי.
    :param lst1: רשימה של מספרים שלמים.
    :param lst2: רשימה של מספרים שלמים.
    :return: רשימה של כל האיברים ש"משקל הנקי" שלהם ייחודי.
                """


    # יצירת מילון מהרשימה הראשונה באמצעות הפונקציה create_dict
    dict1 = create_dict(lst1)
    # יצירת מילון מהרשימה השנייה באמצעות הפונקציה create_dict
    dict2 = create_dict(lst2)
    # יצירת רשימה ריקה לתוצאה
    res = []
    # לולאה שעוברת על כל המפתחות במילון הראשון
    for w in dict1:
        # בדיקה אם המפתח לא נמצא במילון השני
        if w not in dict2:
            # אם המפתח לא נמצא במילון השני, מוסיפים את הערך שלו לרשימת התוצאה
            res.append(dict1[w])
    # לולאה שעוברת על כל המפתחות במילון השני
    for k in dict2:
        # בדיקה אם המפתח לא נמצא במילון הראשון
        if k not in dict1:
            # אם המפתח לא נמצא במילון הראשון, מוסיפים את הערך שלו לרשימת התוצאה
            res.append(dict2[k])
    # החזרת רשימת התוצאה
    return res
```

                   (5 נק') ד

    

   `הסיבוכיות של הפונקציה sort_weight_arr היא O(n^2).`
  הסיבה לכך היא שאנחנו עוברים על כל האיברים ברשימה (O(n)) ועבור כל איבר אנחנו מחשבים את "משקל הנקי" שלו שהוא פעולה של O(n)
  (כיוון שאנחנו עוברים על כל הספרות של המספר). לכן, הסיבוכיות הכוללת היא O(n^2).

`הסיבוכיות של unick_arr היא O(n + m),`
בסך הכול, הסיבוכיות הכוללת של שתי הפונקציות(creat_dict, unick_arr) היא O(n + m),
כאשר n הוא גודל הרשימה המקורית ו-m הוא מספר המפתחות היחודיים במילון.

```python

def main():
    func1() # מימוש שאלה 1
    print(is_valid("AbbAc1A"))  # פונקציה עבור שאלה 2(א).
    func2() # שאלה 2(ב).
    
    print(is_balanced([1,2,5,-5,-1,-2]))  #פונקציה עבור שאלה 3.

    # מימוש של שאלה 4(א)
    # יצירת מופע של המחלקה FlowerPackage
    flower_package = FlowerPackage.delivery("Rose", 5.5)

    # הדפסת המאפיינים של המשלוח
    print(f"Type: {flower_package.type}")
    print(f"Number of flowers: {flower_package.num}")
    print(f"Storage time without water: {flower_package.time}")
    print(f"Price per flower: {flower_package.price}")



    # מימוש של פונקציה :שאלה 4(ד)

    flower1 = FlowerPackage("ROSE", 10, 14, 5.0)
    flower2 = FlowerPackage("LILY", 10, 10, 6.5)
    flower3 = FlowerPackage("TULIP", 10, 13, 4.7)
    flower4 = FlowerPackage("DAISY", 10, 9, 7.0)

    arr = [flower1, flower2, flower3, flower4]

    print(compensation(arr, 12))

    # מימוש שאלה 8 (א)
    # יצירת אובייקט Client
    client_obj = Client("כתובת הלקוח", 3, 100, 80)
    print(f"Before update - Current: {client_obj.current}, Previous: {client_obj.prev}")
    # עדכון קריאת מד המים
    client_obj.update_current(120)
    # הדפסת הערכים לאחר העדכון
    print(f"After update - Current: {client_obj.current}, Previous: {client_obj.prev}")

    # מימוש שאלה 8 (ב)
    # יצירת אובייקט Client
    client_obj = Client("כתובת הלקוח", 3, 100, 80)
    # הדפסת התשלום
    print(client_obj.payment(5, 10))

    # מימוש  שאלה 8 (ג)
    client1 = Client("הדקל 8 ", 4, 120, 80)
    client2 = Client("הרצל 5", 2, 110, 70)
    client3 = Client("שלמה המלך 12", 4, 130, 100)
    client4 = Client("התעשייה 9", 4, 220, 150)
    arr = [client1, client2, client3, client4]
    proposal(arr, 4, 5, 10)  #בסיום תודפס הכתובת ״התעשייה 9״ מכיוון שהצריכה שלהם ל4 אנשים היא הגבוהה מהממוצע


    # מימוש שאלה 9א
    # קריאה לפונקציה clean_weight עם המספר 12345
    print(clean_weight(12345))  # צפוי להדפיס 9

    # שאלה 9ב
    # קריאה לפונקציה sort_weight_arr עם הרשימה [35, 923, 781, 12349, 1892]
    print(sort_weight_arr(
        [35, 923, 781, 12349, 1892]))  # צפוי להדפיס True או False, תלוי באם הרשימה ממוינת לפי "משקל נקי"

    # שאלה 9ג
    # קריאה לפונקציה unick_arr עם שתי הרשימות [35, 923, 781, 12349, 1892] ו-[2, 358, 181, 5821, 1742, 36621, 27731]
    print(unick_arr([35, 923, 781, 12349, 1892],[2, 358, 181, 5821, 1742, 36621, 27731]))  # צפוי להדפיס [923, 12349, 358, 5821, 1742, 36621]

    

if __name__ =="__main__":
    main()
    pass
```
