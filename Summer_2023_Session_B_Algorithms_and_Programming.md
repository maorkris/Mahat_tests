<div dir="rtl">

### חלק א׳   

#### ענו על ארבע מבין השאלות 6-1 (ערך כל שאלה – 12 נקודות) 


                    (12 נק') שאלה 1
כתבו קטע קוד שקולט מספרים שלמים עד שייקלט מספר תלת ספרתי.
יש להדפיס את מספר הגדול ביותר שנקלט ואת מספר הקטן שנקלט.


```python
def func1():
    # הגדרת משתנים למספר המקסימלי והמינימלי
    max_val = None
    min_val = None
    
    # אתחול לולאה אינסופית
    while True:
        # קליטת מספר מהמשתמש
        user_input = int(input("אנא הכנס מספר:"))
    
        # בדיקה אם המספר הוא מספר תלת-ספרתי
        if 99 < abs(user_input) <= 999:
            break
    
        # בדיקה אם זו הפעם הראשונה שמספר מתקבל
        if max_val is None and min_val is None:
            max_val = user_input
            min_val = user_input
    
        # בדיקה אם המספר החדש הוא המספר הגדול ביותר שהתקבל עד כה
        if user_input > max_val:
            max_val = user_input
    
        # בדיקה אם המספר החדש הוא המספר הקטן ביותר שהתקבל עד כה
        if user_input < min_val:
            min_val = user_input
    
    # הדפסת המספר הגדול ביותר והקטן ביותר שהתקבלו
    print(f"המספר הגדול ביותר שהתקבל: {max_val}\nהמספר הקטן ביותר שהתקבל: {min_val}")

    func1()


    
############################################################


def A_three_digit_number():
 # משתנה שיחזיק את המספרים שנקבל מהמשתמש
    num = 0          
# משתנה שיחזיק את המספר הגדול ביותר שהתקבל                              
    big = 0     
# משתנה שיחזיק את המספר הקטן ביותר שהתקבל                                
    low = 0                                     

 # לולאה שתרוץ כל עוד לא התקבלה פקודה שיפסיק
    while True:           
 #  'num' בקשה לקבל מספר מהמשתמש שיוחזק במשתנה                          
        num = int(input("Please enter a number:"))  
#  'big' בדיקה אם המספר שהתקבל גדול מהמשתנה 
#  'num' יהיה שווה ל 'big' אם כן אז 
        if num > big:                               
            big = num                              
 # 0 שווה ל 'low' בשביל הפעם הראשונה עושים בדיקה אם 
 # ועוד בדיקה בשביל שאר הסיבובים אם הוא גדול מהמספר שהתקבל       
        if low == 0 or num < low:                  
            low = num                            
# בדיקה אם לשבור את הלולאה כי התנאי הוא שאם המספר הוא של שלוש ספרות אז לגמור       
        if num >= 100 and num <= 999:               
            break 
# הדפסת ההכי גדול  
    print(big)       
# הדפסת ההכי קטן                          
    print(low)                                  

# קריאה לפונקציה
A_three_digit_number()                            



```
1. [ ] _`הפונקציה abs() היא פונקציה מובנית בשפת Python שמחזירה את הערך המוחלט של מספר. זה אומר שהיא מחזירה את המרחק של המספר מ-0 בציר המספרים. לדוגמה, abs(-5) יחזיר 5 ו-abs(5) גם יחזיר 5.`_

---




                שאלה 2 (12 נק') 

(6 נק') א. מחרוזת "תקינה" היא מחרוזת העונה לשני תנאים הבאים:
• אורך המחרוזת אי-זוגי.
• תו ראשון זהה לתו אמצעי וזהה לתו האחרון.
לדוגמה: המחרוזת **"AbbAc1A"** היא "מחרוזת תקינה".

כתבו פעולה המקבלת מחרוזת ובודקת אם היא "מחרוזת תקינה".
אם כן – הפעולה תחזיר ערך True , ולא – הפעולה תחזיר ערך False.

כותרת הפעולה: `is_valid(s)`

```python
def is_valid(s):
    # הגדרת משתנים שיכילו את התווים: הראשון, האמצעי והאחרון במחרוזת
    first_char,mid_char, last_char = s[0], s[len(s) // 2], s[len(s) -1]
    # בדיקה אם אורך המחרוזת הוא אי-זוגי ובנוסף שהתו הראשון, האמצעי והאחרון זהים
    if len(s) % 2 != 0 and first_char == mid_char == last_char:
        return True

    return False 
print(is_valid("AbbAc1A")) # => output: True



```
`אם תהייתם מה קורה בשורה השנייה בקוד, חשוב שתדעו, יש אפשרות להשמת משתנים ברצף כגון:
`
```python
x,y,z = 1,2,3
print(x) => 1
print(y) => 2
print(z) => 3
```


         (6 נק') ב׳         
כתבו קטע קוד הקולט 23 מחרוזות.
הקטע יחשב וידפיס מספר "מחרוזות תקינות" ומספר מחרוזות לא תקינות.
יש להשתמש בפעולה שכתבתם בסעיף א׳.

```python
def func2():
    # משתנה שמחזיק את מספר המחרוזות התקניות
    validated_strings_count = 0
    
    # לולאה שרצה 23 פעמים
    for i in range(23):
        # קליטת מחרוזת מהמשתמש
        user_input = input("אנא הכנס מחרוזת:")
    
        # בדיקה אם המחרוזת היא תקנית
        if is_valid(user_input):
            # אם המחרוזת תקנית, מוסיפים 1 למשתנה valid
            validated_strings_count += 1
    
    # הדפסת מספר המחרוזות התקניות והלא תקניות
    print(f"מספר המחרוזות התקניות: {validated_strings_count}\nמספר המחרוזות הלא תקניות: {23 - validated_strings_count}")

```

---
      (12  נק') שאלה 3               
רשימה של מספרים שלמים נקראת "רשימה מאוזנת" אם היא עונה על תנאים הבאים:
• כמות האיברים החיוביים שווה לכמות האיברים השליליים.
• הרשימה לא כולל אפסים. כתבו פעולה המקבלת רשימה של מספרים שלמים.
אם הרשימה מאוזנת יש להדפיס אותה מתחילתה ועד סופה בשורה אחת,
ולא – יש להדפיס אותה בסדר הפוך (מסוף הרשימה להתחלה).


```python
def is_balanced(arr):
    #משתנה שמחזיק את הרשימה בסדר הפוך
    reversed_arr = arr[::-1]
    # משתנה שמחזיק את מספר האיברים החיוביים ברשימה
    positive_counter = 0

    # בדיקה אם מספר האיברים ברשימה הוא מספר זוגי
    if len(arr) % 2 == 1:
        # אם כן, מחזירים את הרשימה בסדר הפוך
        return reversed_arr

    # עוברים על כל איבר ברשימה
    for i in arr:
        # אם האיבר הוא אפס, הרשימה אינה מאוזנת
        if i == 0:
            # מחזירים את הרשימה בסדר הפוך
            return reversed_arr

        # אם האיבר הוא מספר חיובי, מוסיפים 1 למונה
        elif i > 0:
            positive_counter += 1

    # בדיקה אם מספר האיברים החיוביים שווה למספר האיברים השליליים
    if len(arr) - positive_counter == positive_counter:
        # אם כן, מחזירים את הרשימה
        return arr

print(is_balanced([1,2,5,-5,-1,-2])) # => output: [1,2,5,-5,-1,-2] is balanced!

  ```

---
                (12 נק') שאלה 4

חברת "פרחי הארץ" מגדלת פרחים ושולחת אותם למכירה לחוץ לארץ.
נתונה מחלקה FlowerPackage המייצגת משלוח פרחים המיועד לשליחה לחו"ל.
למחלקה יש את התכונות הבאות:

• type – סוג הפרח, מטיפוס מחרוזת. •

num – מספר פרחים במשלוח, מטיפוס מספר שלם. 

• time – מספר שעות שניתן להחזיק את הפרחים ללא מים, מטיפוס מספר שלם.

• price – מחיר פרח בודד, מטיפוס מספר ממשי.


במחלקה הוגדרה פעולה בונה (בנאי) המקבל פרמטרים לכל התכונות.


(4 נק') א.
כתבו פעולה בונה המקבלת סוג פרח ומחיר. הפעולה מייצרת משלוח סטנדרטי של 2,000 פרחים.
זמן סטנדרטי שאפשר להחזיק את הפרחים ללא מים – 12 שעות.


```python

class FlowerPackage:
    # פעולה בונה שמקבלת את סוג הפרח, מספר הפרחים, זמן האחסון ללא מים ומחיר הפרח
    def __init__(self, type, num, time, price):
        self.type = type  # סוג הפרח
        self.num = num  # מספר הפרחים
        self.time = time  # זמן האחסון ללא מים
        self.price = price  # מחיר הפרח

    # פעולה שמייצרת משלוח סטנדרטי של 2000 פרחים עם זמן אחסון של 12 שעות
    def delivery(self,flower_type, flower_price):

        # יצירת משלוח חדש עם הפרמטרים הנתונים והגדרות סטנדרטיות למספר הפרחים וזמן האחסון
        new_delivery = FlowerPackage(flower_type,num =2000, time=12, price=flower_price)
        return new_delivery  # מחזירה את המשלוח החדש
    
    
# מימוש של שאלה 4(א)
# יצירת מופע של המחלקה FlowerPackage
flower_package = FlowerPackage.delivery("Rose", 5.5)

# הדפסת המאפיינים של המשלוח
print(f"Type: {flower_package.type}")
print(f"Number of flowers: {flower_package.num}")
print(f"Storage time without water: {flower_package.time}")
print(f"Price per flower: {flower_package.price}")

```
---


 (8 נק') ב
עקב בעיות לוגיסטיות, חברת התעופה מציעה מסלול טיסה ארוך יותר.
חלק ממשלוחים לא ישרדו טיסה ארוכה ואז אי אפשר יהיה למכור את הפרחים.
"פרחי הארץ" תדרוש מחברת התעופה פיצוי על ההפסד הכספי.
כתבו פעולה חיצונית המקבלת רשימה הפניות לעצמים מסוג FlowerPackage בשם arr ואורך הטיסה flyTime.
הפעולה תדפיס פרטי המשלוחים שלא יהיו תקינים.
הפעולה גם תחשב ותדפיס סכום ש"פרחי הארץ" הפסידה. כותרת הפעולה:
                    `compensation(arr, flyTime)`
                    
הנחה: כל איבר ברישמה מכיל הפניה לעצם מסוג FlowerPackage ואין איברים שערכם שווה ל- null.
                    
```python
def compensation(arr, flyTime):
    """
    מחשב את הפיצוי עבור כל הפרחים שזמן ה- flyTime גדול מזמן חיי הפרחים
    הפיצוי מחושב כך: מספר הפרחים כפול המחיר.
    """
    # משתנה שמחזיק את סך הפיצוי
    compensation = 0
    # עוברים על כל הפרחים ברשימה
    for flower in arr:
        # אם משך הטיסה גדול מזמן חיי הפרחים
        if flyTime > flower.time:
            # מוסיפים לסך הפיצוי את מספר הפרחים כפול מחיר הפרח
            compensation += flower.num * flower.price

    # מחזירים את סך הפיצוי
    return compensation

# מימוש של פונקציה :שאלה 4(ב)

flower1 = FlowerPackage("ROSE", 10, 14, 5.0)
flower2 = FlowerPackage("LILY", 10, 10, 6.5)
flower3 = FlowerPackage("TULIP", 10, 13, 4.7)
flower4 = FlowerPackage("DAISY", 10, 9, 7.0)

arr = [flower1, flower2, flower3, flower4]

print(compensation(arr, 12))
```


####  חלק ב' ענו על שתיים מבין השאלות 9-7 (ערך כל שאלה – 15 נקודות).
    
    שאלה 8


לפי התקנון של רשות המים, חיוב עבור צריכת מים ביתית מתבצע לפי השיטה הבאה:
צריכת המים נקבעת על פי קריאת מד המים.
ההפרש בין הקריאה הנוכחית לקריאה הקודמת קובע את כמות הצריכה.
תעריפי המים אחידים בכל הארץ וקובעת אותם הרשות הממשלתית למים וביוב.
סכום החיוב הוא מכפלה של כמויות המים שנצרכו בתקופת החשבון בתעריפי המים.
צריכה ביתית כוללת שני תעריפים:

• תעריף מוזל המתייחס לכמות של שבעה מ"ק לכל נפש המתגוררת ביחידת הדיור.
• ותעריף גבוה המתייחס ליתרת כמות המים שנצרכה ביחידת הדיור בתקופת החשבון. לדוגמה:
אם הצריכה הביתית הייתה 35 מ"ק מים ובדירה מתגוררות ארבע נפשות
יש לשלם עבור 7*4=28 מ"ק לפי התעריף המוזל
ועבור 35-28=7 מ"ק לפי התעריף הגבוה.

חברת "מי הארץ" החליטה למחשב את תהליך גביית התשלום.
לצורך כך הגדירו את המחלקה לקוח (Client) המייצגת יחידת דיור.
למחלקה יש התכונות הבאות:
• address – כתובת, מטיפוס מחרוזת.
• persons – מספר נפשות, מטיפוס מספר שלם.
• current – קריאת מד המים נוכחית, מטיפוס מספר שלם.
• prev – קריאת מד המים קודמת, מטיפוס מספר שלם.

 (5 נק') א'
 כתבו במחלקה Client פעולה לעדכון קריאת מד המים נוכחית.
 הפעולה מקבלת מספר שלם new_current ומעדכנת תכונות current ו- prev בהתאם. כותרת הפעולה:
 update_current(new_current)

   (5 נק') ב׳

 כתבו במחלקה Client את הפעולה לחישוב תשלום.
 הפעולה מקבלת שני תעריפים rate1 (תעריף מוזל) ו-rate2 (תעריף גבוה).
 הפעולה תחזיר סכום לתשלום לפי תקנון של רשות המים. כותרת הפעולה:
 payment(rate1, rate2)

(5 נק') ג.

 """ הנהלת חברת "מי הארץ" החליטה להציע ללקוחות שלה בדיקת מד המים בחינם.
 בשלב ראשון הוחלט לבדוק את מד המים אצל לקוחות שהתשלום
 שלהם גבוה ביחס למשפחות עם אותו מספר נפשות.

 כתבו פעולה חיצונית המקבלת רשימת לקוחות (הפניות לעצמים מטיפוס Client), מספר שלם
 חיובי num המציין את מספר הנפשות ביחידת הדיור ושני תעריפים rate1 (מוזל) ו- rate2 (גבוה).
 הפעולה תדפיס כתובת של כל הלקוחות שיש להם num נפשות ביחידת דיור והתשלום שלהם
 גבוה מממוצע התשלומים של לקוחות עם אותו מספר נפשות. כותרת הפעולה:
 proposal(arr, num, rate1, rate2)"""

```python
class Client:
    def __init__(self, address, persons, current, prev):
        """
        פעולה בונה של האובייקט Client.

        :param address: כתובת הלקוח.
        :param persons: מספר האנשים בבית.
        :param current: צרילת הצרילות הנוכחית.
        :param prev: צרילת הצרילות הקודמת.
        """
        self.address = address
        self.persons = persons
        self.current = current
        self.prev = prev



    def update_current(self, new_current: int):
        """
        פעולה שמעדכנת את הצריכה הקודמת ובהתאם את הנוכחית.
        :param new_current: ערך של הצריכה החדשה.
        """

        self.prev = self.current
        self.current = new_current
        
    
    def payment(self, rate1, rate2):
    """
    פעולה שמחשבת את סכום התשלום על פי תעריפים נתונים.

    :param rate1: תעריף מוזל עבור השימוש במים .
    :param rate2: תעריף רגיל עבור שימוש נוסף מעבר לתקרה המותרת.
    :return: הסכום הכולל לתשלום.
    """

    # משתנה שמייצג את הצריכה במים שיש לשלם
    total_current = self.current - self.prev
    # יצירת משתנה לתיאום התעריף לפי מספר האנשים בבית
    discount_rate = self.persons * 7

    # בדיקה האם הצריכה גדולה או שווה לכמות המים הנתונים פר 7 קוב לנפש
    if  total_current <= discount_rate :
        #הפונקציה תחזיר את התשלום לפי התעריך המוזל
        return total_current * rate1
    else:
        # חישוב תשלום עבור השימוש הנוסף מעבר לתקרה המוזלת
        carry = (total_current - discount_rate) * rate2
        return carry + (discount_rate * rate1)
    
def proposal(arr, num, rate1, rate2):
    """
    הפונקציה מחשבת את התשלום הממוצע של לקוחות שמספר האנשים בבית שלהם שווה ל-num.
    לאחר מכן, הפונקציה מדפיסה את כתובת הלקוח אם התשלום שלו גדול מהתשלום הממוצע.

    :param arr: רשימה של אובייקטים מסוג Client.
    :param num: מספר שלם שמייצג את מספר האנשים בבית.
    :param rate1: תעריף מוזל לשימוש במים.
    :param rate2: תעריף רגיל לשימוש במים שמעבר לתקרה המותרת.
    """

    # מאתחלים את הסכום הכולל של התשלומים ואת מונה הלקוחות ל-0
    total_payment = 0
    count = 0
    # מעבר על כל הלקוחות ברשימה
    for client in arr:
        # אם מספר האנשים בבית של הלקוח שווה ל-num
        if client.persons == num:
            # מוסיפים את תשלום הלקוח לסכום הכולל של התשלומים
            total_payment += client.payment(rate1, rate2)
            # מוסיפים 1 למונה הלקוחות
            count += 1
    # מחשבים את התשלום הממוצע
    average_payment = total_payment / count
    # מעבר שוב על כל הלקוחות ברשימה
    for client in arr:
        # אם מספר האנשים בבית של הלקוח שווה ל-num ותשלום הלקוח גדול מהתשלום הממוצע
        if client.persons == num and client.payment(rate1, rate2) > average_payment:
            # מדפיסים את כתובת הלקוח
            print(client.address)


 # מימוש שאלה 8 (א)
# יצירת אובייקט Client
client_obj = Client("כתובת הלקוח", 3, 100, 80)
print(f"Before update - Current: {client_obj.current}, Previous: {client_obj.prev}")
# עדכון קריאת מד המים
client_obj.update_current(120)
# הדפסת הערכים לאחר העדכון
print(f"After update - Current: {client_obj.current}, Previous: {client_obj.prev}")

# מימוש שאלה 8 (ב)
# יצירת אובייקט Client
client_obj = Client("כתובת הלקוח", 3, 100, 80)
# הדפסת התשלום
print(client_obj.payment(5, 10))

# מימוש  שאלה 8 (ג)
client1 = Client("הדקל 8 ", 4, 120, 80)
client2 = Client("הרצל 5", 2, 110, 70)
client3 = Client("שלמה המלך 12", 4, 130, 100)
client4 = Client("התעשייה 9", 4, 220, 150)
arr = [client1, client2, client3, client4]
proposal(arr, 4, 5, 10)  #בסיום תודפס הכתובת ״התעשייה 9״ מכיוון שהצריכה שלהם ל4 אנשים היא הגבוהה מהממוצע



   ```


                      שאלה 9

נתונות ההגדרות הבאות:
• "משקל נקי" של מספר שלם חיובי הוא סכום הספרות של המספר
בלי הספרה השמאלית ביותר ובלי הספרה הימנית ביותר.
                לדוגמה:
ה"משקל הנקי" של 123 הוא 2.
ה"משקל הנקי" של 12345- הוא 2+3+4=9.
ה"משקל הנקי" של 18 הוא 0.
ה"משקל הנקי" של 9 הוא 0.
• רשימה של מספרים שלמים נקראת "רשימה ממוינת לפי משקלים"
אם ה"משקלים" של כל איברי הרשימה ממוינים בסדר עולה ממש
(ללא חזרות של משקל). לדוגמה: הרשימה הבאה "ממוינת לפי משקלים"

   `[35, 923, 781,1892, 12349, 1892]       `         

                   (3 נק') א


 כתבו פעולה אשר מקבלת מספר שלם חיובי ומחזירה את ה"משקל הנקי" שלו
```python
def clean_weight(num):
    """
פונקציה שמחשבת את "משקל הנקי" של מספר שלם חיובי.
"משקל נקי" הוא סכום הספרות של המספר ללא הספרה השמאלית ביותר וללא הספרה הימנית ביותר.
:param num: מספר שלם חיובי.
:return: משקל הנקי של המספר.
"""
    # המרת המספר למחרוזת
    num_str = str(num)
    # משתנה לסכום המשקל
    sum_weight = 0
    # לולאה שעוברת על כל הספרות של המספר ללא הספרה השמאלית ביותר וללא הספרה הימנית ביותר
    for i in range(1, len(num_str) - 1):
        # הוספת הספרה לסכום המשקל
        sum_weight += int(num_str[i])
    # החזרת המשקל הנקי של המספר
    return sum_weight

print(clean_weight(123))  # => output: 2
print(clean_weight(12345))  # => output: 9
```

                   (5 נק') ב


  כתבו פעולה אשר מקבלת רשימה של מספרים שלמים ומחזירה ערך `True`
 אם הרשימה היא "רשימה ממוינת לפי משקלים", ולא הפעולה תחזיר ערך `False`.
```python
def sort_weight_arr(arr):
    """
    פונקציה שבודקת אם רשימה של מספרים שלמים ממוינת לפי "משקל נקי".
    :param arr: רשימה של מספרים שלמים.
    :return: True אם הרשימה ממוינת לפי "משקל נקי", אחרת False.
    """
    # לולאה שעוברת על כל האיברים ברשימה
    for i in range(len(arr) - 1):
        # בדיקה אם "משקל הנקי" של האיבר הנוכחי גדול מ"משקל הנקי" של האיבר הבא
        if clean_weight(arr[i]) > clean_weight(arr[i + 1]):
            # אם זה המצב, הרשימה אינה ממוינת לפי "משקל נקי"
            return False
    # אם הגענו לסוף הרשימה ללא שום בעיה, הרשימה ממוינת לפי "משקל נקי"
    return True

print(sort_weight_arr([35, 923, 781, 12349, 1892]))  # => output: False
print(sort_weight_arr([35, 923, 781, 1892, 12349, 1892]))  # => output: True

```

                   (5 נק') ג

   
  כתבו פעולה אשר מקבלת שתי רשימות של מספרים שלמים וחיוביים.
  כל את מהרשימות היא "רשימה ממוינת לפי משקלים". הפעולה תדפיס את כל האיברים עם "משקל הנקי" ייחודי
  (כלומר את כל האיברים מהרשימה הראשונה ש"המשקל הנקי" שלהם לא מופיע ברשימה השני ואת ככל האיברים מהרשימה השנייה ש"המשקל הנקי" שלהם לא מופיע ברשימה הראשונה).
  לדוגמה: עבור שתי הרשימות

`list1 = [35, 923, 781, 12349, 1892]`

`list2 = [2, 358, 181, 5821, 1742, 36621, 27731]`

  הפלט יהיה:
  `[923, 12349, 358, 5821, 1742, 36621]`
```python
def create_dict(lst):
    """
פונקציה שמקבלת רשימה של מספרים שלמים ויוצרת מילון שבו המפתחות הם "משקלים נקיים"
של המספרים והערכים הם המספרים עצמם.
:param lst: רשימה של מספרים שלמים.
:return: מילון שבו המפתחות הם "משקלים נקיים" של המספרים והערכים הם המספרים עצמם.
"""
    # יצירת מילון ריק
    dct = {}
    # לולאה שעוברת על כל האיברים ברשימה
    for i in lst:
        # בדיקה אם האיבר לא נמצא כבר במילון
        if i not in dct:
            # אם האיבר לא נמצא במילון, מוסיפים אותו למילון עם המפתח שהוא "משקל הנקי" של המספר
            dct[clean_weight(i)] = i
    # החזרת המילון
    return dct

def unick_arr(lst1, lst2):

    """
    פונקציה שמקבלת שתי רשימות של מספרים שלמים ומחזירה רשימה של כל האיברים ש"משקל הנקי" שלהם ייחודי.
    :param lst1: רשימה של מספרים שלמים.
    :param lst2: רשימה של מספרים שלמים.
    :return: רשימה של כל האיברים ש"משקל הנקי" שלהם ייחודי.
                """


    # יצירת מילון מהרשימה הראשונה באמצעות הפונקציה create_dict
    dict1 = create_dict(lst1)
    # יצירת מילון מהרשימה השנייה באמצעות הפונקציה create_dict
    dict2 = create_dict(lst2)
    # יצירת רשימה ריקה לתוצאה
    res = []
    # לולאה שעוברת על כל המפתחות במילון הראשון
    for w in dict1:
        # בדיקה אם המפתח לא נמצא במילון השני
        if w not in dict2:
            # אם המפתח לא נמצא במילון השני, מוסיפים את הערך שלו לרשימת התוצאה
            res.append(dict1[w])
    # לולאה שעוברת על כל המפתחות במילון השני
    for k in dict2:
        # בדיקה אם המפתח לא נמצא במילון הראשון
        if k not in dict1:
            # אם המפתח לא נמצא במילון הראשון, מוסיפים את הערך שלו לרשימת התוצאה
            res.append(dict2[k])
    # החזרת רשימת התוצאה
    return res

print(unick_arr([35, 923, 781, 12349, 1892], [2, 358, 181, 5821, 1742, 36621, 27731]))  # => output: [923, 12349, 358, 5821, 1742, 36621]

```

                   (5 נק') ד

    

   `הסיבוכיות של הפונקציה sort_weight_arr היא O(n^2).`
  הסיבה לכך היא שאנחנו עוברים על כל האיברים ברשימה (O(n)) ועבור כל איבר אנחנו מחשבים את "משקל הנקי" שלו שהוא פעולה של O(n)
  (כיוון שאנחנו עוברים על כל הספרות של המספר). לכן, הסיבוכיות הכוללת היא O(n^2).

`הסיבוכיות של unick_arr היא O(n + m),`
בסך הכול, הסיבוכיות הכוללת של שתי הפונקציות(creat_dict, unick_arr) היא O(n + m),
כאשר n הוא גודל הרשימה המקורית ו-m הוא מספר המפתחות היחודיים במילון.


                               
### חלק ג'
### ענו על שתיים מבין השאלות 12-10 (ערך כל שאלה – 11 נקודות).


    שאלה 10

נתונה הגדרה הבאה:
רשימה של מספרים שלמים חיוביים נקראת "רשימה ממוינת לפי שארית של k" אם היא עונה על כלל הבא: • בתחילת הרשימה מופעים מספרים שמתחלקים ב- k ללא שארית (עם שארית 0). • אחריהם מופעים מספרים שמתחלקים ב- k עם שארית 1. • אחריהם מופעים מספרים שמתחלקים ב- k עם שארית 2. • אחריהם מופעים מספרים שמתחלקים ב- k עם שארית 3. • וכך הלאה.

לדוגמה: הרשימה הבאה "ממוינת לפי שארית של 4":
`[4,8,1,13,9,2,7,15]
`                  
הרשימה הבאה "ממוינת לפי שארית של 5":
`[15,1,2,7,13,8,4,9]
`

שאלה א׳ (5 נק'):

כתבו פעולה המקבלת רשימה של מספרים שלמים חיוביים arr ומספר שלם חיובי k ובודקת אם היא "רשימה ממוינת לפי שארית של k". אם כן – הפעולה תחזיר ערך True, ולא – הפעולה תחזיר
ערך False.

שאלה ב׳ (4 נק'):

כתבו פעולה המקבל רשימה של מספרים שלמים חיוביים arr ומספר שלם וחיובי k. הפעולה תחזיר רשימה חדשה "הממוית לפי k" הכולל את כל הערכים של הרשימה arr. כותרת הפעולה: sort_by_mod(arr, k)

```python
def is_sorted_by_remainder(lst, k):
    current_remainder = 0  # משתנה שמחזיק את השארית הנוכחית
    for num in lst:  # עובר על כל מספר ברשימה
        mod = num % k  # מחשב את השארית של המספר בחלוקה ב-k
        if mod != current_remainder:  # בודק אם השארית שונה מהשארית הנוכחית
            if mod != current_remainder + 1:  # בודק אם השארית שונה מהשארית הנוכחית + 1
                return False  # אם כן, מחזיר False
            current_remainder += 1  # מעדכן את השארית הנוכחית
    return True  # אם הגענו לכאן, הרשימה ממוינת לפי שארית של k ומחזירים True


def sorted_by_remainder_with_arr(lst, k):
    sort_arr = []  # יוצר רשימה חדשה למיון המספרים
    for index in range(len(lst)):  # עובר על כל אינדקס ברשימה
        for num in lst:  # עובר על כל מספר ברשימה
            if num % k == index:  # בודק אם השארית של המספר בחלוקה ב-k שווה לאינדקס
                sort_arr.append(num)  # אם כן, מוסיף את המספר לרשימה הממוינת

    return sort_arr  # מחזיר את הרשימה הממוינת

# דוגמאות למימוש:
# דוגמה 1:
# הרשימה [4,8,1,13,9,2,7,15] ממוינת לפי שארית של 4
print(is_sorted_by_remainder([4, 8, 1, 13, 9, 2, 7, 15], 4))  # => output: True
# דוגמה 2:
# הרשימה [15,1,2,7,13,8,4,9] אינה ממוינת לפי שארית של 5
print(is_sorted_by_remainder([15, 1, 2, 7, 13, 8, 4, 9], 5))  # => output: False
```




`שאלה 11`

נתונות הגדרות הבאות:

• זוג מספרים שלמים חיוביים שונים זה מזה נקרא "תמורה" (פרמוטציה) אם הם מורכבים מאותן הספרות אבל סדר המופעים של הספרות שונה.

לדוגמה: זוג מספרים `123 ו- 312` הוא "תמורה".

זוג מספרים `1234 ו- 3214` הוא "תמורה".

זוג מספרים `1223 ו- 1323` לא "תמורה".

זוג מספרים `123 ו- 123` לא "תמורה".

• רשימה של מספרים שלמים חיוביים נקראת "רשימת תמורות" אם יש בה לפחות זוג אחד שהוא "תמורה".

• רשימת רשימות של מספרים שלמים חיוביים (רשימה שכל איבר שבה הוא רשימה) נקראת "סופר תמורה"
אם כל איבר שלה היא "רשימת תמורות".

(4 נק') א. כתבו פעולה המקבלת זוג מספרים שלמים חיוביים ובודקת אם הוא "תמורה". אם כן – הפעולה תחזיר ערך `True`, ולא – הפעולה תחזיר ערך `False`.
כותרת הפעולה:                      is_perm(num1, num2)

```python
def is_perm(num1, num2):
    """
    פונקציה שבודקת אם שני מספרים הם פרמוטציה אחת של השנייה.
    פרמוטציה היא סדר של מספרים שניתן לקבל ממספר אחר על ידי שינוי הסדר של הספרות.
    הפונקציה מחזירה True אם המספרים הם פרמוטציה אחת של השנייה, אחרת False.
    """
    # המרת המספרים למחרוזות
    num1 = str(num1)
    num2= str(num2)
    
    # אם המספרים שווים או שאורכם שונה, הם לא יכולים להיות פרמוטציה
    if num1 == num2 or len(num1) != len(num2):
        return False

    # יצירת רשימה ממוינת של הספרות של כל מספר
    lst_num1 = sorted([i for i in num1])
    lst_num2 = sorted([j for j in num2])
    
    # אם הרשימות שוות, המספרים הם פרמוטציה
    return lst_num1 == lst_num2

# דוגמאות למימוש:
# דוגמה 1:
# המספרים 123 ו-321 הם פרמוטציה אחת של השנייה
print(is_perm(123, 321))  # צפוי להחזיר True

# דוגמה 2:
# המספרים 123 ו-124 אינם פרמוטציה אחת של השנייה
print(is_perm(123, 124))  # צפוי להחזיר False


```

(5 נק') ב. כתבו פעולה המקבלת רשימת רשימות של מספרים שלמים חיוביים (רשימה שכל איבר שבה הוא רשימה של מספרים) ובודקת אם היא "סופר תמורה".
אם כן – הפעולה תחזיר ערך `True`, ולא – הפעולה תחזיר ערך `False`.
כותרת הפעולה:


`is_super_perm(arr)`

```python
def contains_permutation_pair(arr):
    """
    פונקציה זו בודקת אם קיים זוג של מספרים במערך שהם פרמוטציה אחת של השני.
    הפונקציה מקבלת מערך של מספרים ומחזירה True אם קיים זוג כזה, אחרת False.
    """
    # עוברים על כל האיברים במערך
    for i in range(len(arr)):
        # עוברים על כל האיברים הנוספים במערך
        for j in range(i + 1, len(arr)):
            # בודקים אם האיבר הנוכחי והאיבר הבא הם פרמוטציה אחת של השני
            if is_perm(arr[i], arr[j]):
                # אם כן, מחזירים True
                return True
    # אם לא מצאנו זוג שהוא פרמוטציה, מחזירים False
    return False

def is_super_parm(arr):
    """
    פונקציה זו בודקת אם כל תת-המערכים במערך הנתון מכילים זוג של מספרים שהם פרמוטציה אחת של השני.
    הפונקציה מקבלת מערך של מערכים של מספרים ומחזירה True אם כל התת-מערכים מכילים זוג כזה, אחרת False.
    """
    # עוברים על כל התת-מערכים במערך
    for lst in arr:
        # בודקים אם התת-מערך מכיל זוג של מספרים שהם פרמוטציה אחת של השני
        if not contains_permutation_pair(lst):
            # אם לא, מחזירים False
            return False
    # אם כל התת-מערכים מכילים זוג כזה, מחזירים True
    return True

# דוגמה למימוש:
# נניח שיש לנו את הפונקציה is_perm שמקבלת שני מספרים ובודקת אם הם פרמוטציה אחת של השני
def is_perm(num1, num2):
    return sorted(str(num1)) == sorted(str(num2))

# דוגמה לשימוש בפונקציה contains_permutation_pair:
print(contains_permutation_pair([123, 321, 456]))  # תחזיר True, מכיוון ש-123 ו-321 הם פרמוטציה אחת של השני

# דוגמה לשימוש בפונקציה is_super_parm:
print(is_super_parm([[123, 321], [456, 654], [789, 987]]))  # תחזיר True, מכיוון שבכל תת-המערך יש זוג שהוא פרמוטציה

```


</div>
